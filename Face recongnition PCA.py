# -*- coding: utf-8 -*-

import numpy as np
import matplotlib.pylab as plt
import os
from numpy import linalg as la
import random

def visualizza(imm):
    M = 112
    N = 92
    if imm.size==N*M:
        plt.imshow(np.reshape(imm,(M,N)))
        plt.show()
    else:
        plt.imshow(imm)
        plt.show()
    return  

# TRAINING PHASE

t = 10 # number of pictures per person
n = 6 # num. of picture in the training set per pers.
p = 40 # number of people
L = n*p #dimension of training set

#i1 = np.array(plt.imread('1.pgm'), dtype='int')
#M = i1.shape[0]
#N = i1.shape[1]

M = 112
N = 92  

f = np.zeros((M*N, L))

path = "C:\\Users\\lucap\\Desktop\\PYTHON\\archive\\archive\\"


k = 0
for i in range(p):
    persona = "s{}".format(i+1)
    for j in range(n):
        imm = "{}.pgm".format(j+1)
        img = np.array(plt.imread(os.path.join(path,persona,imm))) 
        # visualizza(img)
        img = np.reshape(img,M*N)
        f[:,k] = img
        k += 1

f_tilde= 1/L*sum(f[:,l] for l in range(L)) #average face
#visualize(f_tilde) # visualize average face

phi = np.zeros((M*N,L))
for i in range(L):
    phi[:,i] = f[:,i] - f_tilde
    
C = 1/L * np.dot(np.transpose(phi),phi) # covariance matrix (L,L)

eigenValues, eigenVectors = la.eig(C)
idx = eigenValues.argsort()[::-1] #idx in decreasing order
eigenValues = eigenValues[idx]
eigenVectors = eigenVectors[:,idx]

eigenVectors = np.dot(phi,eigenVectors) # eigenvct covariance matrix (MN,MN)

# visualize eigenface j
# j = 3


beta = 10000 # soglia
L_primo = 0
for i in range(L):
    if eigenValues[i] > beta:
        L_primo += 1

eigenValues1 = eigenValues[0:L_primo]
eigenVectors1 = eigenVectors[:,0:L_primo]


percentage = (np.sum(eigenValues1)/np.sum(eigenValues))*100

#Projection faces f[:,i] on subspace generated by eigenfaces
alpha = np.zeros((L_primo,L))
proiezione = np.zeros((N*M,L))
for j in range(L):
    for i in range(L_primo):
        alpha[i,j] = np.inner(phi[:,j],eigenVectors1[:,i])
        proiezione[:,j] = proiezione[:,j] + alpha[i,j]*eigenVectors1[:,i]

#test phase
        
theta = 0.04
        
# choose a picture

pers = random.randint(1,p)
i = random.randint(n+1,t)
persona = "s{}".format(pers) 
imm = "{}.pgm".format(i) 
f_new = np.array(plt.imread(os.path.join(path,persona,imm)))
f_new=np.reshape(f_new,M*N)
visualizza(f_new)
print("Face", i, "of person", pers)

phi_new = f_new - f_tilde
# projection of phi_new on space generated by eigenfaces:


alpha1=np.zeros((L_primo))
for i in range(L_primo):
    alpha1[i]= np.inner(phi_new[:],eigenVectors1[:,i])

epsilon=np.zeros(L)
for i in range(L):
    epsilon[i] = la.norm(alpha[:,i] - alpha1)

epsilon = epsilon/la.norm(epsilon) #normalizzo distanza

eps = np.min(epsilon) #epsilon minimo
ind = np.argmin(epsilon) #indice corrispondente
        
if eps<theta:
    print("The face is in the database and corresponds to the face",np.mod(ind,n)+1 ,"of the person",int(np.floor(ind/n+1)))
    visualizza(f[:,ind])
else:
    print("The face is not in the database")

    
        
